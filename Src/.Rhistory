res <- predict(mdl,
newdata = data_calib,
type="quantile",
p=alpha)
quant <-  res
score <- pmin(c,quant)-data_calib$censored_T
## The fitted quantile for the new data
newdata <- data.frame(x)
colnames(newdata) <- xnames
res <- predict(mdl,
newdata = newdata,
type="quantile",
p=alpha)
new_quant <-  res
## Compute the calibration term
calib_term <- sapply(X=weight_new,get_calibration,score=score,
weight_calib=weight_calib,alpha=alpha)
## obtain final confidence interval
lower_bnd <- pmin(new_quant,c)-calib_term
}
if(type == "percentile"){
## Fit the model for S(y)=p(min(T,c)>=y|X)
xnames <- paste0("X",1:p)
data_fit <- data_fit[data_fit$C>=c,]
data_fit$censored_T <- pmin(data_fit$censored_T,c)
surv_data_fit <- data_fit
surv_data_fit$censored_T <- -surv_data_fit$censored_T
fmla <- with(surv_data_fit,as.formula(paste("censored_T ~ ", paste(xnames, collapse= "+"))))
if(p==1){
capture.output(bw <- npcdistbw(fmla),file='NULL')
}else{
capture.output(bw <- npcdistbw(fmla,ftol=ftol,tol=tol),file='NULL')
}
surv_data_calib <- data_calib
surv_data_calib$censored_T <- -surv_data_calib$censored_T
score<- npcdist(bws=bw,newdata = surv_data_calib)$condist
## Obtain the calibration term
calib_term <- sapply(X=weight_new,get_calibration,score=score,
weight_calib=weight_calib,alpha=alpha)
## Obtain the final confidence interval
lower_bnd <- rep(0,len_x)
newdata <- data.frame(x)
colnames(newdata) <- xnames
for(i in 1:len_x){
time_candidate <- seq(0,c+2,by=.1)
score_candidate <- sapply(-time_candidate,get_survival_fun,x = newdata[i,],bw=bw,xnames=xnames)
ind <- min(which(score_candidate<=calib_term[i]))
if(ind>1){
lower_bnd[i] <- time_candidate[ind-1]
}else{
lower_bnd[i] <- 0
}
}
}
lower_bnd <- pmax(lower_bnd,0)
lower_bnd <- pmin(lower_bnd,c)
return(lower_bnd)
}
get_survival_fun <- function(x,t,bw,xnames){
input_data <- data.frame(x)
colnames(input_data) <- xnames
input_data <- cbind(input_data,censored_T=t)
val<- npcdist(bws=bw,newdata=input_data)$condist
return(val)
}
cox_based()
library(readxl)
data <- read_excel("../dataset/TrainingSet.xlsx", col_names = TRUE)
library(readxl)
library(survival)
library(survminer)
library(dplyr)
library(ggplot2)
library(knitr)
library(broom)
library(tidyr)
summary(data)
table(data$Users, data$Status)
table(data$Purpose, data$Status)
table(data$Orbit, data$Status)
table(data$Continent, data$Status)
i <- which(data$Purpose == 'Navigation' | data$Orbit == 'Elliptical' | data$Continent == 'Africa' | data$Continent == 'Multinational' | data$Continent == 'Oceania' )
data <- data[-i,]
table(data$Users, data$Status)
table(data$Purpose, data$Status)
table(data$Orbit, data$Status)
table(data$Continent, data$Status)
table(data$Status)
i <- which(data$Eccentricity == 0)
data$Eccentricity[i] = 1
data$log.Eccentricity <- -log(data$Eccentricity)
time <- data$`Effective Lifetime`
status <- data$Status
cox <- coxph(Surv(time,status == 'retired') ~  Apogee + log.Eccentricity   +
Mass + Users + strata(Purpose) + Continent + strata(Orbit), data = data)
summary(cox)
test.set <- read_excel("../Dataset/TestSet.xlsx", col_names = TRUE)
i <- which(test.set$Purpose == 'Navigation' | test.set$Orbit == 'Elliptical' | test.set$Continent == 'Africa' | test.set$Continent == 'Multinational' | test.set$Continent == 'Oceania' )
test.set <- test.set[-i,]
table(test.set$Users, test.set$Status)
table(test.set$Purpose, test.set$Status)
table(test.set$Orbit, test.set$Status)
table(test.set$Continent, test.set$Status)
table(test.set$Status)
i <- which(test.set$Eccentricity == 0)
test.set$Eccentricity[i] = 1
test.set$log.Eccentricity <- -log(test.set$Eccentricity)
coxed <- coxed::coxed(cox, newdata = test.set, method="npsf", bootstrap = TRUE, B=750)
predicted_lifetime <- coxed$exp.dur
library('cfsurvival')
covariates <-c('Apogee','log.Eccentricity','Mass','Users', 'Purpose', 'Continent', 'Orbit' )
X.test <- test.set[, covariates]
X.train <- data[, covariates]
n=dim(X.train)[1]
n_test=dim(X.test)[1]
Event <- ifelse(data$Status == 'censored', FALSE, TRUE )
C = data$`Effective Lifetime`
id=which(data$Status=="retired")
data$`Launch Date` <- as.Date(data$`Launch Date`)
data$`Launch Date` <- as.POSIXct(data$`Launch Date`)
data$`Final Date`<- as.Date(data$`Final Date`)
data$`Final Date` <- as.POSIXct(data$`Final Date`)
C[id]= data$`Final Date`[234] - data$`Launch Date`[id] # Censoring times
#C[id]= as.matrix(data$`Final Date`[234], nrow=length(id), cnol=1) - data$`Launch Date`[id] # Censoring times
censored_T = data$`Effective Lifetime`
censored_T
View(X.test)
test.set
View(test.set)
C = test.set$`Effective Lifetime`
id=which(test.set$Status=="retired")
test.set$`Launch Date` <- as.Date(test.set$`Launch Date`)
test.set$`Launch Date` <- as.POSIXct(test.set$`Launch Date`)
test.set$`Final Date`<- as.Date(test.set$`Final Date`)
test.set$`Final Date` <- as.POSIXct(test.set$`Final Date`)
C[id]= test.set$`Final Date`[234] - test.set$`Launch Date`[id] # Censoring times
#C[id]= as.matrix(data$`Final Date`[234], nrow=length(id), cnol=1) - data$`Launch Date`[id] # Censoring times
censored_T = test.set$`Effective Lifetime`
censored_T.test = test.set$`Effective Lifetime`
C = test.set$`Effective Lifetime`
id=which(test.set$Status=="retired")
test.set$`Launch Date` <- as.Date(test.set$`Launch Date`)
test.set$`Launch Date` <- as.POSIXct(test.set$`Launch Date`)
test.set$`Final Date`<- as.Date(test.set$`Final Date`)
test.set$`Final Date` <- as.POSIXct(test.set$`Final Date`)
C[id]= test.set$`Final Date`[234] - test.set$`Launch Date`[id] # Censoring times
#C[id]= as.matrix(data$`Final Date`[234], nrow=length(id), cnol=1) - data$`Launch Date`[id] # Censoring times
censored_Ttest = test.set$`Effective Lifetime`
cox_based <- function(X.test, censored_Ttest, alpha = 0.5,
train_data,
calibration_data,
type = 'quantile',
dist = 'weibull',
weight_calib,
weight_new,
ftol=.1,tol=.1)
cox_based <- function(X.test, censored_Ttest, alpha = 0.5,
train_data,
calibration_data,
type = 'quantile',
dist = 'weibull',
0,
cox_based <- function(X.test, censored_Ttest, alpha = 0.5,
train_data,
calibration_data,
type = 'quantile',
dist = 'weibull',
weight_calib = numeric(0),
weight_new = numeric(0),
ftol=.1,tol=.1)
weight_calib
weight_calib = numeric(0)
weight_calib
# Running cfsurvival with c0 = 10
c0 <- 8  ## coverage corretto
pr_list <- rep(0.5, n)  ## provare a cambiare prior
pr_new_list <- rep(0.5, n_test)
res <- cfsurv(x = X.test, c_list = c0, pr_list = pr_list, pr_new_list = pr_new_list,
Xtrain = X.train, C = C, event = Event, time = censored_T, model = "cox",
alpha = 0.1) #, model = "aft")
# Running cfsurvival with c0 = 10
c0 <- 8  ## coverage corretto
pr_list <- rep(0.5, n)  ## provare a cambiare prior
pr_new_list <- rep(0.5, n_test)
res <- cfsurv(x = X.test, c_list = c0, pr_list = pr_list, pr_new_list = pr_new_list,
Xtrain = X.train, C = C, event = Event, time = censored_T,
alpha = 0.1, model = "cox")
# Running cfsurvival with c0 = 10
c0 <- 8  ## coverage corretto
pr_list <- rep(0.5, n)  ## provare a cambiare prior
pr_new_list <- rep(0.5, n_test)
res <- cfsurv(x = X.test, c_list = c0, pr_list = pr_list, pr_new_list = pr_new_list,
Xtrain = X.train, C = C, event = Event, time = censored_T,
alpha = 0.1)
covariates <-c('Apogee','log.Eccentricity','Mass','Users', 'Purpose', 'Continent', 'Orbit' )
X.test <- test.set[, covariates]
X.train <- data[, covariates]
n=dim(X.train)[1]
n_test=dim(X.test)[1]
Event <- ifelse(data$Status == 'censored', FALSE, TRUE )
C = data$`Effective Lifetime`
id=which(data$Status=="retired")
data$`Launch Date` <- as.Date(data$`Launch Date`)
data$`Launch Date` <- as.POSIXct(data$`Launch Date`)
data$`Final Date`<- as.Date(data$`Final Date`)
data$`Final Date` <- as.POSIXct(data$`Final Date`)
C[id]= data$`Final Date`[234] - data$`Launch Date`[id] # Censoring times
#C[id]= as.matrix(data$`Final Date`[234], nrow=length(id), cnol=1) - data$`Launch Date`[id] # Censoring times
censored_T = data$`Effective Lifetime`
# Running cfsurvival with c0 = 10
c0 <- 8  ## coverage corretto
pr_list <- rep(0.5, n)  ## provare a cambiare prior
pr_new_list <- rep(0.5, n_test)
res <- cfsurv(x = X.test, c_list = c0, pr_list = pr_list, pr_new_list = pr_new_list,
Xtrain = X.train, C = C, event = Event, time = censored_T,
alpha = 0.1)
# Examine the result
T <- test.set$`Effective Lifetime`
cat(sprintf("The coverage is %.3f.\n", mean(res <= T)))
# Assumiamo che 'res' sia l'output della funzione cfsurv
lower_bound <- res
upper_bound <- +Inf
# Creiamo un dataframe con i limiti inferiori e superiori
df <- data.frame(Index = 1:length(lower_bound), LowerBound = lower_bound, UpperBound = upper_bound)
T <- test.set$`Effective Lifetime`
if (!require(dplyr)) {
install.packages("dplyr")
library(dplyr)
}
set.seed(10)
# Seleziona casualmente 10 righe dal dataframe
df_sample <- df %>% sample_n(10)
T_sample <- sample(T, 10)
# Crea il grafico con il dataframe campione
ggplot(data=df, aes(x=Index, y=LowerBound)) +
geom_segment(aes(xend=Index, yend=Inf), color=pastel_colors[1], size = 3) +
geom_point(aes(y = T),size=2.5, color = pastel_colors[2]) +
coord_flip() +
labs(x = "Index", y = "Confidence Interval and Effective Lifetime",
title = "Conformal Prediction Interval and Effective Lifetime for Survival Time") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5),
text = element_text(size=12, family="sans", color="black"))
# Creiamo una palette di colori pastello
pastel_colors <- brewer.pal(12, "Paired")
barplot(rep(1,9), col = pastel_colors, space = 0, border = NA, ylab = "", xlab = "", xaxt = 'n', yaxt = 'n')
T <- test.set$`Effective Lifetime`
if (!require(dplyr)) {
install.packages("dplyr")
library(dplyr)
}
set.seed(10)
# Seleziona casualmente 10 righe dal dataframe
df_sample <- df %>% sample_n(10)
T_sample <- sample(T, 10)
# Crea il grafico con il dataframe campione
ggplot(data=df, aes(x=Index, y=LowerBound)) +
geom_segment(aes(xend=Index, yend=Inf), color=pastel_colors[1], size = 3) +
geom_point(aes(y = T),size=2.5, color = pastel_colors[2]) +
coord_flip() +
labs(x = "Index", y = "Confidence Interval and Effective Lifetime",
title = "Conformal Prediction Interval and Effective Lifetime for Survival Time") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5),
text = element_text(size=12, family="sans", color="black"))
T <- test.set$`Effective Lifetime`
if (!require(dplyr)) {
install.packages("dplyr")
library(dplyr)
}
set.seed(10)
# Seleziona casualmente 10 righe dal dataframe
df_sample <- df %>% sample_n(10)
T_sample <- sample(T, 10)
# Crea il grafico con il dataframe campione
ggplot(data=df, aes(x=Index, y=LowerBound)) +
geom_segment(aes(xend=Index, yend=Inf), color=pastel_colors[1], size = 3) +
geom_point(aes(y = T),linewidth=2.5, color = pastel_colors[2]) +
coord_flip() +
labs(x = "Index", y = "Confidence Interval and Effective Lifetime",
title = "Conformal Prediction Interval and Effective Lifetime for Survival Time") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5),
text = element_text(size=12, family="sans", color="black"))
T <- test.set$`Effective Lifetime`
if (!require(dplyr)) {
install.packages("dplyr")
library(dplyr)
}
set.seed(10)
# Seleziona casualmente 10 righe dal dataframe
df_sample <- df %>% sample_n(10)
T_sample <- sample(T, 10)
# Crea il grafico con il dataframe campione
ggplot(data=df, aes(x=Index, y=LowerBound)) +
geom_segment(aes(xend=Index, yend=Inf), color=pastel_colors[1], linewidth = 2) +
geom_point(aes(y = T),linewidth=1, color = pastel_colors[2]) +
coord_flip() +
labs(x = "Index", y = "Confidence Interval and Effective Lifetime",
title = "Conformal Prediction Interval and Effective Lifetime for Survival Time") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5),
text = element_text(size=12, family="sans", color="black"))
T <- test.set$`Effective Lifetime`
if (!require(dplyr)) {
install.packages("dplyr")
library(dplyr)
}
set.seed(10)
# Seleziona casualmente 10 righe dal dataframe
df_sample <- df %>% sample_n(10)
T_sample <- sample(T, 10)
# Crea il grafico con il dataframe campione
ggplot(data=df, aes(x=Index, y=LowerBound)) +
geom_segment(aes(xend=Index, yend=Inf), color=pastel_colors[1], linewidth = 1) +
geom_point(aes(y = T),linewidth=1, color = pastel_colors[2]) +
coord_flip() +
labs(x = "Index", y = "Confidence Interval and Effective Lifetime",
title = "Conformal Prediction Interval and Effective Lifetime for Survival Time") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5),
text = element_text(size=12, family="sans", color="black"))
T <- test.set$`Effective Lifetime`
if (!require(dplyr)) {
install.packages("dplyr")
library(dplyr)
}
set.seed(10)
# Seleziona casualmente 10 righe dal dataframe
df_sample <- df %>% sample_n(10)
T_sample <- sample(T, 10)
# Crea il grafico con il dataframe campione
ggplot(data=df, aes(x=Index, y=LowerBound)) +
geom_segment(aes(xend=Index, yend=Inf), color=pastel_colors[1], size = 1) +
geom_point(aes(y = T),linewidth=1, color = pastel_colors[2]) +
coord_flip() +
labs(x = "Index", y = "Confidence Interval and Effective Lifetime",
title = "Conformal Prediction Interval and Effective Lifetime for Survival Time") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5),
text = element_text(size=12, family="sans", color="black"))
T <- test.set$`Effective Lifetime`
if (!require(dplyr)) {
install.packages("dplyr")
library(dplyr)
}
set.seed(10)
# Seleziona casualmente 10 righe dal dataframe
df_sample <- df %>% sample_n(10)
T_sample <- sample(T, 10)
# Crea il grafico con il dataframe campione
ggplot(data=df, aes(x=Index, y=LowerBound)) +
geom_segment(aes(xend=Index, yend=Inf), color=pastel_colors[1], size = 1) +
geom_point(aes(y = T),size=1, color = pastel_colors[2]) +
coord_flip() +
labs(x = "Index", y = "Confidence Interval and Effective Lifetime",
title = "Conformal Prediction Interval and Effective Lifetime for Survival Time") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5),
text = element_text(size=12, family="sans", color="black"))
plot(percentile(test.set$Period), res, type ='l')
plot(quantile(test.set$Period), res, type ='l')
quantile(test.set$Period)
probs = seq(1:100)
probs
quantile(test.set$Period, probs = seq(1:100)
)
seq(0:0.1:1)
quantile(test.set$Period, probs = seq(0,1,0.1))
quantile(test.set$Period, probs = seq(0,1,0.01))
plot(quantile(test.set$Period, probs = seq(0,1,0.01)), res, type ='l')
# Crea 100 suddivisioni casuali
splits <- split(res, rep(1:100, each = length(res) / 100))
# Calcola la mediana per ciascuna suddivisione
medians <- sapply(splits, median)
# Calcola la media delle mediane
media_delle_mediane <- mean(medians)
media_delle_mediane
medians
plot(quantile(test.set$Period, probs = seq(0,1,0.01)), medians, type ='l')
quantile(test.set$Period, probs = seq(0,1,0.01))
perc <- quantile(test.set$Period, probs = seq(0,1,0.01))
length(perc)
plot(perc[1:100], medians, type ='l')
library(readxl)
data <- read_excel("../dataset/TrainingSet.xlsx", col_names = TRUE)
library(readxl)
library(survival)
library(survminer)
library(dplyr)
library(ggplot2)
library(knitr)
library(broom)
library(tidyr)
summary(data)
table(data$Users, data$Status)
table(data$Purpose, data$Status)
table(data$Orbit, data$Status)
table(data$Continent, data$Status)
i <- which(data$Purpose == 'Navigation' | data$Orbit == 'Elliptical' | data$Continent == 'Africa' | data$Continent == 'Multinational' | data$Continent == 'Oceania' )
data <- data[-i,]
table(data$Users, data$Status)
table(data$Purpose, data$Status)
table(data$Orbit, data$Status)
table(data$Continent, data$Status)
table(data$Status)
table(data$Users, data$Status)
table(data$Purpose, data$Status)
table(data$Orbit, data$Status)
table(data$Continent, data$Status)
table(data$Status)
i <- which(data$Eccentricity == 0)
data$Eccentricity[i] = 1
data$log.Eccentricity <- -log(data$Eccentricity)
time <- data$`Effective Lifetime`
status <- data$Status
covariates <- c( "Perigee" ,"Apogee", 'log.Eccentricity', "Inclination", "Period", "Mass", "Users", "Purpose", "Continent", "Orbit")
cox1bis <- coxph(Surv(time,status == 'retired') ~ ., data = data[,covariates])
summary(cox1bis)
time <- data$`Effective Lifetime`
status <- data$Status
cox5bis <- coxph(Surv(time,status == 'retired') ~  Apogee + log.Eccentricity   +
Mass + Users + strata(Purpose) + Continent + strata(Orbit), data = data)
summary(cox5bis)
test.set <- read_excel("../Dataset/TestSet.xlsx", col_names = TRUE)
i <- which(test.set$Purpose == 'Navigation' | test.set$Orbit == 'Elliptical' | test.set$Continent == 'Africa' | test.set$Continent == 'Multinational' | test.set$Continent == 'Oceania' )
test.set <- test.set[-i,]
table(test.set$Users, test.set$Status)
table(test.set$Purpose, test.set$Status)
table(test.set$Orbit, test.set$Status)
table(test.set$Continent, test.set$Status)
table(test.set$Status)
i <- which(test.set$Eccentricity == 0)
test.set$Eccentricity[i] = 1
test.set$log.Eccentricity <- -log(test.set$Eccentricity)
bashaz.train <- basehaz(cox5bis)
bashaz.train
table(bashaz.train$strata) # strata su orbit e Purpose --> 8 combinazioni in teoria
bashaz.test <- basehaz(cox5bis, test.set, centered=TRUE)
bashaz.test
table(bashaz.test$strata)
# technology DEvelopment, Geo non esiste
table(test.set$Orbit, test.set$Purpose)
# technology DEvelopment, Geo non esiste neanche nel test set -> buono
data.frame(bashaz.test)
p = data.frame(bashaz.test)
View(p)
library(readxl)
data <- read_excel("../dataset/TrainingSet.xlsx", col_names = TRUE)
library(readxl)
library(survival)
library(survminer)
library(dplyr)
library(ggplot2)
library(knitr)
library(broom)
library(tidyr)
summary(data)
table(data$Users, data$Status)
table(data$Purpose, data$Status)
table(data$Orbit, data$Status)
table(data$Continent, data$Status)
i <- which(data$Purpose == 'Navigation' | data$Orbit == 'Elliptical' | data$Continent == 'Africa' | data$Continent == 'Multinational' | data$Continent == 'Oceania' )
data <- data[-i,]
table(data$Users, data$Status)
table(data$Purpose, data$Status)
table(data$Orbit, data$Status)
table(data$Continent, data$Status)
table(data$Status)
i <- which(data$Eccentricity == 0)
data$Eccentricity[i] = 1
data$log.Eccentricity <- -log(data$Eccentricity)
time <- data$`Effective Lifetime`
status <- data$Status
cox <- coxph(Surv(time,status == 'retired') ~  Apogee + log.Eccentricity   +
Mass + Users + strata(Purpose) + Continent + strata(Orbit), data = data)
summary(cox)
test.set <- read_excel("../Dataset/TestSet.xlsx", col_names = TRUE)
i <- which(test.set$Purpose == 'Navigation' | test.set$Orbit == 'Elliptical' | test.set$Continent == 'Africa' | test.set$Continent == 'Multinational' | test.set$Continent == 'Oceania' )
test.set <- test.set[-i,]
table(test.set$Users, test.set$Status)
table(test.set$Purpose, test.set$Status)
table(test.set$Orbit, test.set$Status)
table(test.set$Continent, test.set$Status)
table(test.set$Status)
i <- which(test.set$Eccentricity == 0)
test.set$Eccentricity[i] = 1
test.set$log.Eccentricity <- -log(test.set$Eccentricity)
bashaz.train <- basehaz(cox)
bashaz.train
table(bashaz.train$strata) # strata su orbit e Purpose --> 8 combinazioni in teoria
bashaz.test <- basehaz(cox5, test.set, centered=TRUE)
bashaz.test <- basehaz(cox, test.set, centered=TRUE)
bashaz.test
table(bashaz.test$strata)
# technology DEvelopment, Geo non esiste
table(test.set$Orbit, test.set$Purpose)
# technology DEvelopment, Geo non esiste neanche nel test set -> buono
## S3 method for class 'coxph'
expLP = predict(cox5, test.set,
#type=c("lp", "risk", "expected", "terms", "survival"),
type = 'risk',
reference=c("strata", "sample", "zero"))
## S3 method for class 'coxph'
expLP = predict(cox, test.set,
#type=c("lp", "risk", "expected", "terms", "survival"),
type = 'risk',
reference=c("strata", "sample", "zero"))
id <- which(test.set$Status == 'retired')
diff <- predicted_lifetime$exp.dur[id] - test.set$`Effective Lifetime`[id]
coxed <- coxed::coxed(cox, newdata = test.set, method="npsf", bootstrap = TRUE, B=750)
predicted_lifetime <- coxed$exp.dur
