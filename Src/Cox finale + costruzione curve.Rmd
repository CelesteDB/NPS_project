
```{r}
library(readxl)
data <- read_excel("../dataset/TrainingSet.xlsx", col_names = TRUE)
```

Libraries:
```{r,'error=FALSE', 'warning=FALSE'}
library(readxl)
library(survival)
library(survminer)
library(dplyr) 
library(ggplot2)
library(knitr)
library(broom)
library(tidyr)
```

Summary:
```{r}
summary(data)
```
Conto numero eventi per ogni covariata
```{r}
table(data$Users, data$Status)
table(data$Purpose, data$Status)
table(data$Orbit, data$Status)
table(data$Continent, data$Status)


```
Dalla letteratura risulta che non ho abbastanza eventi per Navigation, Elliptical, Africa, Multinational, Oceania
Simulation work has suggested that at least 10 events need to be observed for each covariate considered, and anything less will lead to problems.
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2376927/

Rimuoviamo queste classi
```{r}
i <- which(data$Purpose == 'Navigation' | data$Orbit == 'Elliptical' | data$Continent == 'Africa' | data$Continent == 'Multinational' | data$Continent == 'Oceania' )
data <- data[-i,]
```

A livello di continenti è un confronto tra America, Asia e Europa: Maggiori potenze economiche 

Controlliamo
```{r}
table(data$Users, data$Status)
table(data$Purpose, data$Status)
table(data$Orbit, data$Status)
table(data$Continent, data$Status)
table(data$Status)
```


Trasformo Eccentricità per avere un miglior grafico dei residui
```{r}
i <- which(data$Eccentricity == 0)
data$Eccentricity[i] = 1
data$log.Eccentricity <- -log(data$Eccentricity)
```


```{r}
time <- data$`Effective Lifetime`
status <- data$Status

cox <- coxph(Surv(time,status == 'retired') ~  Apogee + log.Eccentricity   +
                Mass + Users + strata(Purpose) + Continent + strata(Orbit), data = data)
summary(cox)

```

## Previsione

```{r}
library(coxed)

ed1 <- coxed(cox5bis, method="npsf")
predlife=ed1$exp.dur
#mean and median of the predicted durations:
ed1$mean
ed1$median

# PLOT: The estimated cumulative baseline hazard function and survivor function
baseline <- gather(ed1$baseline.functions, cbh, survivor, key="survivefunction", value="value")
ggplot(baseline, aes(x=time, y=value)) +
     geom_line() +
     xlab("Time") +
     ylab("Function") +
     facet_wrap( ~ survivefunction, scales = "free")
```
PREDICTION

Preparazione test set
```{r}
test.set <- read_excel("../Dataset/TestSet.xlsx", col_names = TRUE)
```


```{r}
i <- which(test.set$Purpose == 'Navigation' | test.set$Orbit == 'Elliptical' | test.set$Continent == 'Africa' | test.set$Continent == 'Multinational' | test.set$Continent == 'Oceania' )
test.set <- test.set[-i,]
```

```{r}
table(test.set$Users, test.set$Status)
table(test.set$Purpose, test.set$Status)
table(test.set$Orbit, test.set$Status)
table(test.set$Continent, test.set$Status)
table(test.set$Status)
```
Trasformo Eccentricità per avere un miglior grafico dei residui
```{r}
i <- which(test.set$Eccentricity == 0)
test.set$Eccentricity[i] = 1
test.set$log.Eccentricity <- -log(test.set$Eccentricity)
```



Per ottenere baseline hazard dei nuovi dati
```{r}
bashaz.train <- basehaz(cox)
bashaz.train
table(bashaz.train$strata) # strata su orbit e Purpose --> 8 combinazioni in teoria
```


```{r}
bashaz.test <- basehaz(cox5, test.set, centered=TRUE)
bashaz.test
table(bashaz.test$strata)
# technology DEvelopment, Geo non esiste  
table(test.set$Orbit, test.set$Purpose)
# technology DEvelopment, Geo non esiste neanche nel test set -> buono 

```
strata = 1 --> hazard riferita alla prima osservazione


```{r}
## S3 method for class 'coxph'
expLP = predict(cox5bis, test.set,
#type=c("lp", "risk", "expected", "terms", "survival"),
type = 'risk',
reference=c("strata", "sample", "zero"))
```

Prediction
```{r}
# a mano: Idea imprlementare quello che fa Coxed (Incluso bootstrap) in modo da poter usare strata
# Qui il link di coxed : https://github.com/jkropko/coxed/blob/master/R/coxed.R
```


```{r}
coxed <- coxed::coxed(cox5bis, newdata = test.set, method="npsf", bootstrap = TRUE, B=750)
predicted_lifetime <- coxed$exp.dur
```



```{r}
id <- which(test.set$Status == 'retired')
diff <- predicted_lifetime$exp.dur[id] - test.set$`Effective Lifetime`[id]
plot(diff)

```
```{r}
sqrt(sum(diff^2)/length(diff))
mean(diff)
median(diff)
#mean(test.set$`Effective Lifetime`[id])
```
```{r}


# Calculate Concordance Index
c_index <- survConcordance(Surv(test.set$`Effective Lifetime`, predicted_lifetime$exp.dur) ~ predicted_lifetime$exp.dur)
print(paste("Concordance Index: ", c_index$concordance))

```
```{r}
diff <- predicted_lifetime$exp.dur[id] - test.set$`Expected Lifetime`[id]
plot(diff)
```

```{r}
sorted_lt <- predicted_lifetime[order(predicted_lifetime$exp.dur),]

t <- seq(0, max(test.set$`Effective Lifetime`), length = length(sorted_lt$exp.dur))
plot(t, sorted_lt$exp.dur, type = 'l', lwd = 2)
lines(t, sorted_lt$lb)
lines(t, sorted_lt$ub)
```