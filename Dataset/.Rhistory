{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- mean(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric(t(diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
p_val <- sum(T2>=T20)/B
return(p_val)
}
grid=seq(-10,10,by=1)
length(grid)
# library(pbapply)
# library(parallel)
#
# n_cores <- detectCores()
# n_cores
#
# cl = makeCluster(n_cores)
#
# clusterExport(cl,varlist=list("diff","test1"))
#
# perm_wrapper <- function(grid_point) {
#   test1(grid_point)  # run a permutational t test where the hypothesised mean is the grid_point
#}
#pval_function <- pbsapply(grid, perm_wrapper, cl = cl)
pval_function <- numeric(length(grid))
i = 0
for (theta in grid) {
pval_function[i] = test1(theta)
i = i+1
}
alpha <- 0.05  # set the significance level
plot(grid, pval_function, type = "l")  # plot p-value function
values.within.CI <- grid[pval_function > alpha]
CI <- range(values.within.CI)  # obtain the confidence interval
abline(v=CI[1], col="red")
abline(v=CI[2], col="red")
t1=explife
t2=predlife
p=1
n1=n
n2=n
t1.mean <- mean(t1)
t2.mean <- mean(t2)
t1.cov  <-  var(t1)
t2.cov  <-  var(t2)
Sp      <- ((n1-1)*t1.cov + (n2-1)*t2.cov)/(n1+n2-2)  # pooled cov matrix
Spinv   <- solve(Sp)
diff <- t1-t2
diff.mean <- mean(diff)
diff.cov <- var(diff)
diff.invcov <- solve(diff.cov)
test1 <- function(delta.0) {
T20 <- as.numeric(t(diff.mean-delta.0)  %*% (diff.mean-delta.0))
T2 <- numeric(B)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- mean(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric(t(diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
p_val <- sum(T2>=T20)/B
return(p_val)
}
grid=seq(-10,10,by=1)
length(grid)
library(pbapply)
library(parallel)
n_cores <- detectCores()
n_cores
cl = makeCluster(n_cores)
clusterExport(cl,varlist=list("diff","test1"))
perm_wrapper <- function(grid_point) {
test1(grid_point)  # run a permutational t test where the hypothesised mean is the grid_point
}
pval_function <- pbsapply(grid, perm_wrapper, cl = cl)
t1=explife
t2=predlife
diff <- t1-t2
test1 <- function(diff, delta.0, B = 1000) {
diff.mean <- mean(diff)
diff.cov <- var(diff)
diff.invcov <- solve(diff.cov)
T20 <- as.numeric(t(diff.mean-delta.0)  %*% (diff.mean-delta.0))
T2 <- numeric(B)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- mean(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric(t(diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
p_val <- sum(T2>=T20)/B
return(p_val)
}
grid=seq(-10,10,by=1)
length(grid)
library(pbapply)
library(parallel)
n_cores <- detectCores()
n_cores
cl = makeCluster(n_cores)
clusterExport(cl,varlist=list("diff","test1"))
perm_wrapper <- function(grid_point) {
test1(diff, grid_point, B=2000)  # run a permutational t test where the hypothesised mean is the grid_point
}
pval_function <- pbsapply(grid, perm_wrapper, cl = cl)
t1=explife
t2=predlife
diff <- t1-t2
test1 <- function(diff, delta.0, B = 1000) {
diff.mean <- mean(diff)
diff.cov <- var(diff)
diff.invcov <- solve(diff.cov)
n <- length(diff)
p <- 1
T20 <- as.numeric(t(diff.mean-delta.0)  %*% (diff.mean-delta.0))
T2 <- numeric(B)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- mean(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric(t(diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
p_val <- sum(T2>=T20)/B
return(p_val)
}
grid=seq(-10,10,by=1)
length(grid)
library(pbapply)
library(parallel)
n_cores <- detectCores()
n_cores
cl = makeCluster(n_cores)
clusterExport(cl,varlist=list("diff","test1"))
perm_wrapper <- function(grid_point) {
test1(diff, grid_point, B=2000)  # run a permutational t test where the hypothesised mean is the grid_point
}
pval_function <- pbsapply(grid, perm_wrapper, cl = cl)
t1=explife
t2=predlife
diff <- t1-t2
test1 <- function(diff, delta.0, B = 1000) {
diff.mean <- mean(diff)
diff.cov <- var(diff)
diff.invcov <- solve(diff.cov)
n1 <- length(diff)
p <- 1
T20 <- as.numeric(t(diff.mean-delta.0)  %*% (diff.mean-delta.0))
T2 <- numeric(B)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- mean(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric(t(diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
p_val <- sum(T2>=T20)/B
return(p_val)
}
grid=seq(-10,10,by=1)
length(grid)
library(pbapply)
library(parallel)
n_cores <- detectCores()
n_cores
cl = makeCluster(n_cores)
clusterExport(cl,varlist=list("diff","test1"))
perm_wrapper <- function(grid_point) {
test1(diff, grid_point, B=2000)  # run a permutational t test where the hypothesised mean is the grid_point
}
pval_function <- pbsapply(grid, perm_wrapper, cl = cl)
# pval_function <- numeric(length(grid))
# i = 0
# for (theta in grid) {
#   pval_function[i] = test1(theta)
#   i = i+1
# }
alpha <- 0.05  # set the significance level
plot(grid, pval_function, type = "l")  # plot p-value function
values.within.CI <- grid[pval_function > alpha]
CI <- range(values.within.CI)  # obtain the confidence interval
abline(v=CI[1], col="red")
abline(v=CI[2], col="red")
t1=explife
t2=predlife
diff <- t1-t2
test1 <- function(diff, delta.0, B = 1000) {
diff.mean <- mean(diff)
diff.cov <- var(diff)
diff.invcov <- solve(diff.cov)
n1 <- length(diff)
p <- 1
T20 <- as.numeric(t(diff.mean-delta.0)  %*% (diff.mean-delta.0))
T2 <- numeric(B)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- mean(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric(t(diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
p_val <- sum(T2>=T20)/B
return(p_val)
}
grid=seq(-30,30,by=0.1)
length(grid)
library(pbapply)
library(parallel)
n_cores <- detectCores()
n_cores
cl = makeCluster(n_cores)
clusterExport(cl,varlist=list("diff","test1"))
perm_wrapper <- function(grid_point) {
test1(diff, grid_point, B=2000)  # run a permutational t test where the hypothesised mean is the grid_point
}
pval_function <- pbsapply(grid, perm_wrapper, cl = cl)
# pval_function <- numeric(length(grid))
# i = 0
# for (theta in grid) {
#   pval_function[i] = test1(theta)
#   i = i+1
# }
alpha <- 0.05  # set the significance level
plot(grid, pval_function, type = "l")  # plot p-value function
values.within.CI <- grid[pval_function > alpha]
CI <- range(values.within.CI)  # obtain the confidence interval
abline(v=CI[1], col="red")
abline(v=CI[2], col="red")
t1=explife
t2=predlife
diff <- t1-t2
test1 <- function(diff, delta.0, B = 1000) {
diff.mean <- mean(diff)
diff.cov <- var(diff)
diff.invcov <- solve(diff.cov)
n1 <- length(diff)
p <- 1
T20 <- as.numeric(t(diff.mean-delta.0)  %*% (diff.mean-delta.0))
T2 <- numeric(B)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- mean(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric(t(diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
p_val <- sum(T2>=T20)/B
return(p_val)
}
grid=seq(-60,5,by=0.1)
length(grid)
library(pbapply)
library(parallel)
n_cores <- detectCores()
n_cores
cl = makeCluster(n_cores)
clusterExport(cl,varlist=list("diff","test1"))
perm_wrapper <- function(grid_point) {
test1(diff, grid_point, B=2000)  # run a permutational t test where the hypothesised mean is the grid_point
}
pval_function <- pbsapply(grid, perm_wrapper, cl = cl)
# pval_function <- numeric(length(grid))
# i = 0
# for (theta in grid) {
#   pval_function[i] = test1(theta)
#   i = i+1
# }
alpha <- 0.05  # set the significance level
plot(grid, pval_function, type = "l")  # plot p-value function
values.within.CI <- grid[pval_function > alpha]
CI <- range(values.within.CI)  # obtain the confidence interval
abline(v=CI[1], col="red")
abline(v=CI[2], col="red")
T.obs <- mean(diff)
cl=makeCluster(parallel::detectCores()/2)
clusterExport(cl=cl,list('diff'))
T.boot=pbreplicate(B,
median(sample(x1, replace = T)),
cl=cl)
hist(diff)
hist(t2)
hist(t1)
hist(t1-t2)
hist(t2-t1)
mean(diff)
hist(diff)
CI
alpha <- 0.05  # set the significance level
plot(grid, pval_function, type = "l")  # plot p-value function
values.within.CI <- grid[pval_function > alpha]
T.obs <- mean(diff)
cl=makeCluster(parallel::detectCores()/2)
clusterExport(cl=cl,list('diff'))
T.boot=pbreplicate(B,
mean(sample(diff, replace = T)),
cl=cl)
plot(ecdf(T.boot), main='Sample mean of the difference')
abline(v = T.obs, lty=2)
T.obs
T.obs <- mean(diff)
cl=makeCluster(parallel::detectCores()/2)
clusterExport(cl=cl,list('diff'))
T.boot=pbreplicate(B,
mean(sample(diff, replace = T)),
cl=cl)
plot(ecdf(T.boot), main='Sample mean of the difference')
abline(v = T.obs, lty=2)
t1=explife
t2=predlife
diff <- t1-t2
test1 <- function(diff, delta.0, B = 1000) {
diff.mean <- mean(diff)
diff.cov <- var(diff)
diff.invcov <- solve(diff.cov)
n1 <- length(diff)
p <- 1
T20 <- as.numeric(t(diff.mean-delta.0)  %*% (diff.mean-delta.0))
T2 <- numeric(B)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- mean(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric(t(diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
p_val <- sum(T2>=T20)/B
return(p_val)
}
grid=seq(-60,5,by=0.1)
length(grid)
library(pbapply)
library(parallel)
n_cores <- detectCores()
n_cores
cl = makeCluster(n_cores)
clusterExport(cl,varlist=list("diff","test1"))
perm_wrapper <- function(grid_point) {
test1(diff, grid_point, B=2000)  # run a permutational t test where the hypothesised mean is the grid_point
}
pval_function <- pbsapply(grid, perm_wrapper, cl = cl)
# pval_function <- numeric(length(grid))
# i = 0
# for (theta in grid) {
#   pval_function[i] = test1(theta)
#   i = i+1
# }
alpha <- 0.05  # set the significance level
plot(grid, pval_function, type = "l")  # plot p-value function
values.within.CI <- grid[pval_function > alpha]
CI <- range(values.within.CI)  # obtain the confidence interval
abline(v=CI[1], col="red")
abline(v=CI[2], col="red")
diff.mean
length(grid)
diff
dim(diff)
length(diff)
t1=explife
t2=predlife
diff <- t1-t2
test1 <- function(diff, delta.0, B = 1000) {
data_trans <- diff - delta.0
T0 <- mean(data_trans)*mean(data_trans)
T_perm <- numeric(B)
n1 <- length(diff)
p <-1
# diff.mean <- mean(diff)
# diff.cov <- var(diff)
# diff.invcov <- solve(diff.cov)
# n1 <- length(diff)
# p <- 1
#
# T20 <- as.numeric(t(diff.mean-delta.0)  %*% (diff.mean-delta.0))
#
# T2 <- numeric(B)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
data_trans_perm <- data_trans * signs.perm
T_perm[perm] <- mean(data_trans_perm)*mean(data_trans_perm)
# diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
# diff.mean_perm <- mean(diff_perm)
# diff.cov_perm <- cov(diff_perm)
# diff.invcov_perm <- solve(diff.cov_perm)
#
# T2[perm] <- as.numeric(t(diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
p_val <- sum(T_perm >= T0)/B
#p_val <- sum(T2>=T20)/B
return(p_val)
}
grid=seq(-60,5,by=0.1)
length(grid)
library(pbapply)
library(parallel)
n_cores <- detectCores()
n_cores
cl = makeCluster(n_cores)
clusterExport(cl,varlist=list("diff","test1"))
perm_wrapper <- function(grid_point) {
test1(diff, grid_point, B=2000)
}
pval_function <- pbsapply(grid, perm_wrapper, cl = cl)
# pval_function <- numeric(length(grid))
# i = 0
# for (theta in grid) {
#   pval_function[i] = test1(theta)
#   i = i+1
# }
alpha <- 0.05  # set the significance level
plot(grid, pval_function, type = "l")  # plot p-value function
values.within.CI <- grid[pval_function > alpha]
CI <- range(values.within.CI)  # obtain the confidence interval
abline(v=CI[1], col="red")
abline(v=CI[2], col="red")
t1=explife
t2=predlife
diff <- t1-t2
test1 <- function(diff, delta.0, B = 1000) {
data_trans <- diff - delta.0
T0 <- abs(mean(data_trans))
T_perm <- numeric(B)
n1 <- length(diff)
p <-1
# diff.mean <- mean(diff)
# diff.cov <- var(diff)
# diff.invcov <- solve(diff.cov)
# n1 <- length(diff)
# p <- 1
#
# T20 <- as.numeric(t(diff.mean-delta.0)  %*% (diff.mean-delta.0))
#
# T2 <- numeric(B)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
data_trans_perm <- data_trans * signs.perm
T_perm[perm] <- abs(mean(data_trans_perm))
# diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
# diff.mean_perm <- mean(diff_perm)
# diff.cov_perm <- cov(diff_perm)
# diff.invcov_perm <- solve(diff.cov_perm)
#
# T2[perm] <- as.numeric(t(diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
p_val <- sum(T_perm >= T0)/B
#p_val <- sum(T2>=T20)/B
return(p_val)
}
grid=seq(-60,5,by=0.1)
length(grid)
library(pbapply)
library(parallel)
n_cores <- detectCores()
n_cores
cl = makeCluster(n_cores)
clusterExport(cl,varlist=list("diff","test1"))
perm_wrapper <- function(grid_point) {
test1(diff, grid_point, B=2000)
}
pval_function <- pbsapply(grid, perm_wrapper, cl = cl)
# pval_function <- numeric(length(grid))
# i = 0
# for (theta in grid) {
#   pval_function[i] = test1(theta)
#   i = i+1
# }
alpha <- 0.05  # set the significance level
plot(grid, pval_function, type = "l")  # plot p-value function
values.within.CI <- grid[pval_function > alpha]
CI <- range(values.within.CI)  # obtain the confidence interval
abline(v=CI[1], col="red")
abline(v=CI[2], col="red")
